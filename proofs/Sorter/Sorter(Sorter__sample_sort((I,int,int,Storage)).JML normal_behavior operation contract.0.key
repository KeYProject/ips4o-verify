\withOptions moreSeqRules:on;

\javaSource "../../src";

\chooseContract "de.wiesler.Sorter[de.wiesler.Sorter::sample_sort([I,int,int,de.wiesler.Storage)].JML normal_behavior operation contract.0";

\proofScript "

macro autopilot-prep;

select succedent formula='{_values:=values
  || heapBefore_sample_sort:=heap
  || heap:=store(memset(store(store(store(create(heap, x_arr_2),
                                          x_arr_2,
                                          java.lang.Object::<transient>,
                                          Z(0(#))),
                                    x_arr_2,
                                    java.lang.Object::<transactionConditionallyUpdated>,
                                    FALSE),
                              x_arr_2,
                              java.lang.Object::<initialized>,
                              FALSE),
                        arrayRange(x_arr_2, Z(0(#)), Z(8(2(1(#))))),
                        Z(0(#))),
                 x_arr_2,
                 java.lang.Object::<initialized>,
                 TRUE)
  || heap_Before_BLOCK:=store(memset(store(store(store(create(heap, x_arr_2),
                                                       x_arr_2,
                                                       java.lang.Object::<transient>,
                                                       Z(0(#))),
                                                 x_arr_2,
                                                 java.lang.Object::<transactionConditionallyUpdated>,
                                                 FALSE),
                                           x_arr_2,
                                           java.lang.Object::<initialized>,
                                           FALSE),
                                     arrayRange(x_arr_2, Z(0(#)), Z(8(2(1(#))))),
                                     Z(0(#))),
                              x_arr_2,
                              java.lang.Object::<initialized>,
                              TRUE)
  || exc#78_1:=null}
   seqPerm(seqDef{int u;}(Z(0(#)), length(_values), any::select(heap, _values, arr(u))),
           seqDef{int u;}(Z(0(#)), length(_values), any::select(heapBefore_sample_sort, _values, arr(u))))';

macro onestep;

let @seqAfterCreate='seqDef{int u;}(0,
                        values.length,
                        any::select(heap[create(x_arr_2)]
                                        [x_arr_2.<transient> := 0]
                                        [x_arr_2.<transactionConditionallyUpdated> := FALSE]
                                        [x_arr_2.<initialized> := FALSE]
                                        [memset(arrayRange(x_arr_2, 0, 128), 0)]
                                        [x_arr_2.<initialized> := TRUE],
                                    values,
                                    arr(u)))'
    @seqPre='seqDef{int u;}(0, values.length, any::select(heap, values, arr(u)))';

cut '@seqAfterCreate = @seqPre';
rule applyEq formula='seqPerm(@seqAfterCreate, @seqPre)' on='@seqAfterCreate';
auto;
auto;

select succedent formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_fallback_sort}
   seqPerm(seqDef{int u;}(Z(0(#)), length(values), any::select(heap, values, arr(u))),
           seqDef{int u;}(Z(0(#)), length(values), any::select(heapAtPre, values, arr(u))))';

rule seqPermTrans formula='seqPerm(seqDef{int u;}(0, values.length, any::select(heapAfter_fallback_sort, values, arr(u))),
         seqDef{int u;}(0, values.length, any::select(heapAfter_partition, values, arr(u))))';

rule seqPermTrans formula='seqPerm(seqDef{int u;}(0, values.length, any::select(heapAfter_fallback_sort, values, arr(u))),
         seqDef{int u;}(0,
                        values.length,
                        any::select(heap[create(x_arr_2)]
                                        [x_arr_2.<transient> := 0]
                                        [x_arr_2.<transactionConditionallyUpdated> := FALSE]
                                        [x_arr_2.<initialized> := FALSE]
                                        [memset(arrayRange(x_arr_2, 0, 128), 0)],
                                    values,
                                    arr(u))))';
auto;

select succedent formula='{heapAtPre:=heap
  || exc:=null
  || heap:=anon(heapAfter_partition,
                union(allFields(storage), arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                anonOut_heap<<anonHeapFunction>>)}
   \forall Field f;
     \forall java.lang.Object o;
       (  o = values & \exists int iv; (f = arr(iv) & geq(iv, begin) & leq(iv, add(Z(neglit(1(#))), end)))
        | o = storage
        | !o = null
        & !boolean::select(heapAtPre, o, java.lang.Object::<created>) = TRUE
        | any::select(heapAtPre, o, f) = any::select(heap, o, f))';

rule hide_left formula='\forall int b;
   (   lt(b, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & geq(b, Z(0(#)))
    ->   de.wiesler.Functions::isSortedSlice(anon(heapAfter_partition,
                                                  union(allFields(storage),
                                                        arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                  anonOut_heap<<anonHeapFunction>>),
                                             values,
                                             add(begin,
                                                 int::select(anon(heapAfter_partition,
                                                                  union(allFields(storage),
                                                                        arrayRange(values,
                                                                                   begin,
                                                                                   add(Z(neglit(1(#))), end))),
                                                                  anonOut_heap<<anonHeapFunction>>),
                                                             x_arr_2,
                                                             arr(b))),
                                             add(begin,
                                                 int::select(anon(heapAfter_partition,
                                                                  union(allFields(storage),
                                                                        arrayRange(values,
                                                                                   begin,
                                                                                   add(Z(neglit(1(#))), end))),
                                                                  anonOut_heap<<anonHeapFunction>>),
                                                             x_arr_2,
                                                             arr(add(Z(1(#)), b)))))
       = TRUE)';

rule hide_left formula='\forall int b;
   (   lt(b, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & geq(b, Z(0(#)))
    ->   de.wiesler.Sorter::isBucketPartitioned(anon(heapAfter_partition,
                                                     union(allFields(storage),
                                                           arrayRange(values,
                                                                      begin,
                                                                      add(Z(neglit(1(#))), end))),
                                                     anonOut_heap<<anonHeapFunction>>),
                                                values,
                                                begin,
                                                end,
                                                int::select(anon(heapAfter_partition,
                                                                 union(allFields(storage),
                                                                       arrayRange(values,
                                                                                  begin,
                                                                                  add(Z(neglit(1(#))), end))),
                                                                 anonOut_heap<<anonHeapFunction>>),
                                                            x_arr_2,
                                                            arr(b)),
                                                int::select(anon(heapAfter_partition,
                                                                 union(allFields(storage),
                                                                       arrayRange(values,
                                                                                  begin,
                                                                                  add(Z(neglit(1(#))), end))),
                                                                 anonOut_heap<<anonHeapFunction>>),
                                                            x_arr_2,
                                                            arr(add(Z(1(#)), b))))
       = TRUE)';

rule hide_left formula='de_wiesler_Sorter_PartitionResult_equal_buckets_0<<selectSK>> = TRUE
 -> \forall int b;
      (     lt(b, add(Z(neglit(1(#))), de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>))
          & geq(b, Z(0(#)))
          & jmod(b, Z(2(#))) = Z(1(#))
       -> \forall int i;
            (     lt(i, int::select(heapAfter_partition, x_arr_2, arr(add(Z(1(#)), b))))
                & geq(i, int::select(heapAfter_partition, x_arr_2, arr(b)))
             ->   int::select(heapAfter_partition, values, arr(add(begin, i)))
                = int::select(heapAfter_partition,
                              values,
                              arr(add(begin, int::select(heapAfter_partition, x_arr_2, arr(b)))))))';
auto;

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null}
   \forall int b;
     (   geq(b, Z(0(#))) & lt(b, num_buckets)
      ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap, bucket_starts, arr(add(Z(1(#)), b))))
         = TRUE)';

macro onestep;
rule allRight;
instantiate hide var='b' occ='1' with='b_0';
auto;

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null}
   seqPerm(seqDef{int u;}(0, _values.length, any::select(heap, _values, arr(u))),
           seqDef{int u;}(0,
                          _valuesBefore_sample_sort.length,
                          any::select(heapBefore_sample_sort, _valuesBefore_sample_sort, arr(u))))';

rule seqPermTrans formula='seqPerm(seqDef{int u;}(0, values.length, values[u]@heapAfter_partition),
         seqDef{int u;}(0,
                        values.length,
                        any::select(heap[create(x_arr_2)]
                                        [x_arr_2.<transient> := 0]
                                        [x_arr_2.<transactionConditionallyUpdated> := FALSE]
                                        [x_arr_2.<initialized> := FALSE]
                                        [memset(arrayRange(x_arr_2, 0, 128), 0)],
                                    values,
                                    arr(u))))';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null}
   \forall int b;
     (   b >= 0 & b < num_buckets
      ->   de.wiesler.Functions.isSortedSlice(_values,
                                              _begin + bucket_starts[b],
                                              _begin + bucket_starts[1 + b])
         = TRUE)';
macro onestep;
rule allRight;

instantiate hide var='b' occ='2' with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap:=anon(heapAfter_partition,
                union(allFields(storage), arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                anonOut_heap<<anonHeapFunction>>)
  || heap_Before_BLOCK_1:=anon(heapAfter_partition,
                               union(allFields(storage),
                                     arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                               anonOut_heap<<anonHeapFunction>>)
  || exc#67_1:=null}
   (  de.wiesler.Lemma::sortednessFromPartitionSorted(heap,
                                                      _values,
                                                      _begin,
                                                      _end,
                                                      bucket_starts,
                                                      num_buckets)
    = TRUE)';
macro onestep;
rule Contract_axiom_for_sortednessFromPartitionSorted_in_Lemma on='de.wiesler.Lemma::sortednessFromPartitionSorted(anon(heapAfter_partition,
                                                        union(allFields(storage),
                                                              arrayRange(values,
                                                                         begin,
                                                                         add(Z(neglit(1(#))), end))),
                                                        anonOut_heap<<anonHeapFunction>>),
                                                   values,
                                                   begin,
                                                   end,
                                                   x_arr_2,
                                                   de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)';
rule impLeft occ='0';
macro autopilot-prep;

select succedent formula='\forall int b_0;
   (   leq(Z(0(#)), b_0) & lt(b_0, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & inInt(b_0)
    ->   de.wiesler.Sorter::isBucketPartitioned(anon(heapAfter_partition,
                                                     union(allFields(storage),
                                                           arrayRange(values,
                                                                      begin,
                                                                      add(Z(neglit(1(#))), end))),
                                                     anonOut_heap<<anonHeapFunction>>),
                                                values,
                                                begin,
                                                end,
                                                int::select(anon(heapAfter_partition,
                                                                 union(allFields(storage),
                                                                       arrayRange(values,
                                                                                  begin,
                                                                                  add(Z(neglit(1(#))), end))),
                                                                 anonOut_heap<<anonHeapFunction>>),
                                                            x_arr_2,
                                                            arr(b_0)),
                                                int::select(anon(heapAfter_partition,
                                                                 union(allFields(storage),
                                                                       arrayRange(values,
                                                                                  begin,
                                                                                  add(Z(neglit(1(#))), end))),
                                                                 anonOut_heap<<anonHeapFunction>>),
                                                            x_arr_2,
                                                            arr(javaAddInt(b_0, Z(1(#))))))
       = TRUE)';
rule allRight;
instantiate hide var='b' occ='4' with='b_0_0';

select succedent formula='\forall int b;
   (   leq(Z(0(#)), b) & lt(b, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & inInt(b)
    ->   de.wiesler.Functions::isSortedSlice(anon(heapAfter_partition,
                                                  union(allFields(storage),
                                                        arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                  anonOut_heap<<anonHeapFunction>>),
                                             values,
                                             javaAddInt(begin,
                                                        int::select(anon(heapAfter_partition,
                                                                         union(allFields(storage),
                                                                               arrayRange(values,
                                                                                          begin,
                                                                                          add(Z(neglit(1(#))),
                                                                                              end))),
                                                                         anonOut_heap<<anonHeapFunction>>),
                                                                    x_arr_2,
                                                                    arr(b))),
                                             javaAddInt(begin,
                                                        int::select(anon(heapAfter_partition,
                                                                         union(allFields(storage),
                                                                               arrayRange(values,
                                                                                          begin,
                                                                                          add(Z(neglit(1(#))),
                                                                                              end))),
                                                                         anonOut_heap<<anonHeapFunction>>),
                                                                    x_arr_2,
                                                                    arr(javaAddInt(b, Z(1(#)))))))
       = TRUE)';
rule allRight;
instantiate hide var='b' occ='3' with='b_0';

select succedent
    formula='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                       union(allFields(storage),
                                                             arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                       anonOut_heap<<anonHeapFunction>>),
                                                  values,
                                                  begin,
                                                  end)
             = TRUE';

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                    union(allFields(storage),
                                                                          arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                    anonOut_heap<<anonHeapFunction>>),
                                                               values,
                                                               begin,
                                                               end)'
    inst_termWithSmallHeap='de.wiesler.Functions::isValidSlice(heap, values, begin, end)'
                   formula='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                      union(allFields(storage),
                                                                            arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                      anonOut_heap<<anonHeapFunction>>),
                                                                 values,
                                                                 begin,
                                                                 end)
                            = TRUE'
                        on='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                    union(allFields(storage),
                                                                          arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                    anonOut_heap<<anonHeapFunction>>),
                                                               values,
                                                               begin,
                                                               end)';

select succedent formula='  de.wiesler.Lemma::bucketIndexFromOffset(anon(heapAfter_partition,
                                                union(allFields(storage),
                                                      arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                anonOut_heap<<anonHeapFunction>>),
                                           x_arr_2,
                                           de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                           javaSubInt(end, begin))
 = TRUE';

rule Contract_axiom_for_isValidBucketStarts_in_Functions
         formula='de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                              x_arr_2,
                                                              de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
                  = TRUE'
      inst_sv_p0='x_arr_2'
    inst_sv_heap='heapAfter_partition'
      inst_sv_p1='de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>'
              on='de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                            x_arr_2,
                                                            de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)';

rule eqTermCut
    formula='!x_arr_2 = null & wellFormed(heapAfter_partition)
             ->   de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                            x_arr_2,
                                                            de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
                = TRUE
             ->   de.wiesler.Lemma::bucketIndexFromOffset(heapAfter_partition,
                                                          x_arr_2,
                                                          de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                          int::select(heapAfter_partition,
                                                                      x_arr_2,
                                                                      arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)))
                = TRUE'
     inst_s='javaSubInt(end, begin)'
     inst_t='int::select(heapAfter_partition,
                         x_arr_2,
                         arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>))'
         on='int::select(heapAfter_partition,
                         x_arr_2,
                         arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>))';

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Lemma::bucketIndexFromOffset(anon(heapAfter_partition,
                                                                         union(allFields(storage),
                                                                               arrayRange(values,
                                                                                          begin,
                                                                                          add(Z(neglit(1(#))), end))),
                                                                         anonOut_heap<<anonHeapFunction>>),
                                                                    x_arr_2,
                                                                    de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                                    javaSubInt(end, begin))'
    inst_termWithSmallHeap='de.wiesler.Lemma::bucketIndexFromOffset(heapAfter_partition,
                                                                    x_arr_2,
                                                                    de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                                    javaSubInt(end, begin))'
                   formula='de.wiesler.Lemma::bucketIndexFromOffset(anon(heapAfter_partition,
                                                                           union(allFields(storage),
                                                                                 arrayRange(values,
                                                                                            begin,
                                                                                            add(Z(neglit(1(#))), end))),
                                                                           anonOut_heap<<anonHeapFunction>>),
                                                                      x_arr_2,
                                                                      de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                                      javaSubInt(end, begin))
                            = TRUE'
                        on='de.wiesler.Lemma::bucketIndexFromOffset(anon(heapAfter_partition,
                                                                         union(allFields(storage),
                                                                               arrayRange(values,
                                                                                          begin,
                                                                                          add(Z(neglit(1(#))), end))),
                                                                         anonOut_heap<<anonHeapFunction>>),
                                                                    x_arr_2,
                                                                    de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                                    javaSubInt(end, begin))';
auto;
macro onestep;
rule andRight;

select succedent formula='  de.wiesler.Functions::isValidBucketStarts(anon(heapAfter_partition,
                                                  union(allFields(storage),
                                                        arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                  anonOut_heap<<anonHeapFunction>>),
                                             x_arr_2,
                                             de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
 = TRUE';
rule Contract_axiom_for_isValidBucketStarts_in_Functions
         formula='de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                              x_arr_2,
                                                              de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
                  = TRUE'
      inst_sv_p0='x_arr_2'
    inst_sv_heap='heapAfter_partition'
      inst_sv_p1='de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>'
              on='de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                            x_arr_2,
                                                            de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)';

rule eqTermCut
    formula='!x_arr_2 = null & wellFormed(heapAfter_partition)
             ->   de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                            x_arr_2,
                                                            de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
                = TRUE
             ->   de.wiesler.Lemma::bucketIndexFromOffset(heapAfter_partition,
                                                          x_arr_2,
                                                          de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>,
                                                          int::select(heapAfter_partition,
                                                                      x_arr_2,
                                                                      arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)))
                = TRUE'
     inst_s='javaSubInt(end, begin)'
     inst_t='int::select(heapAfter_partition,
                         x_arr_2,
                         arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>))'
         on='int::select(heapAfter_partition,
                         x_arr_2,
                         arr(de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>))';

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Functions::isValidBucketStarts(anon(heapAfter_partition,
                                                                           union(allFields(storage),
                                                                                 arrayRange(values,
                                                                                            begin,
                                                                                            add(Z(neglit(1(#))), end))),
                                                                           anonOut_heap<<anonHeapFunction>>),
                                                                      x_arr_2,
                                                                      de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)'
    inst_termWithSmallHeap='de.wiesler.Functions::isValidBucketStarts(heapAfter_partition,
                                                                      x_arr_2,
                                                                      de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)'
                   formula='de.wiesler.Functions::isValidBucketStarts(anon(heapAfter_partition,
                                                                             union(allFields(storage),
                                                                                   arrayRange(values,
                                                                                              begin,
                                                                                              add(Z(neglit(1(#))), end))),
                                                                             anonOut_heap<<anonHeapFunction>>),
                                                                        x_arr_2,
                                                                        de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)
                            = TRUE'
                        on='de.wiesler.Functions::isValidBucketStarts(anon(heapAfter_partition,
                                                                           union(allFields(storage),
                                                                                 arrayRange(values,
                                                                                            begin,
                                                                                            add(Z(neglit(1(#))), end))),
                                                                           anonOut_heap<<anonHeapFunction>>),
                                                                      x_arr_2,
                                                                      de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>)';
auto;
macro onestep;
rule andRight;

# equal_buckets true

# invariant initially

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || equal_buckets:=TRUE
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=0}
   seqPerm(array2seq(heap, _values), array2seq(heapBefore_sample_sort, _valuesBefore_sample_sort))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(0, values.length, values[u]@heapAfter_partition),
         seqDef{int u;}(0,
                        values.length,
                        any::select(heap[create(x_arr_2)]
                                        [x_arr_2.<transient> := 0]
                                        [x_arr_2.<transactionConditionallyUpdated> := FALSE]
                                        [x_arr_2.<initialized> := FALSE]
                                        [memset(arrayRange(x_arr_2, 0, 128), 0)],
                                    values,
                                    arr(u))))';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || equal_buckets:=TRUE
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   \forall int b;
     (   leq(Z(0(#)), b) & lt(b, num_buckets) & inInt(b)
      ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap,
                                                              bucket_starts,
                                                              arr(javaAddInt(b, Z(1(#))))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide var='b' occ='1' with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || equal_buckets:=TRUE
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   \forall int b;
     (   leq(bucket, b) & lt(b, num_buckets) & inInt(b)
      ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap,
                                                              bucket_starts,
                                                              arr(javaAddInt(b, Z(1(#))))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide var='b' occ='2' with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || equal_buckets:=TRUE
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   \forall int b;
     (     (leq(Z(0(#)), b)
         & lt(b, javaSubInt(num_buckets, Z(1(#))))
         & javaMod(b, Z(2(#))) = Z(1(#)))<<SC>>
         & inInt(b)
      -> \forall int i;
           (     leq(int::select(heap, bucket_starts, arr(b)), i)
               & lt(i, int::select(heap, bucket_starts, arr(javaAddInt(b, Z(1(#))))))
               & inInt(i)
            ->   int::select(heap,
                             _values,
                             arr(javaAddInt(_begin, int::select(heap, bucket_starts, arr(b)))))
               = int::select(heap, _values, arr(javaAddInt(_begin, i)))))';
macro onestep;
rule allRight;
instantiate hide var='b' occ='3' with='b_0';
rule impRight;
rule impLeft;
auto;
rule allRight;
instantiate hide var='i' occ='1' with='i_0';

# end invariant initially

# body preserves invariant
select succedent formula='seqPerm(seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(heapAfter_sample_sort_recurse_on, values, arr(u))),
         seqDef{int u;}(Z(0(#)), length(values), any::select(heap, values, arr(u))))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(heapAfter_sample_sort_recurse_on, values, arr(u))),
         seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(anon(heapAfter_partition,
                                         union(allFields(storage),
                                               arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                         anon_heap_LOOP<<anonHeapFunction>>),
                                    values,
                                    arr(u))))';
auto;

select branch='Pre (sample_sort_recurse_on)';
macro onestep;
leave;
# end body preserves invariant

select branch='Pre (sample_sort_recurse_on)';
macro onestep;
leave;

# post final recursion

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=heapAfter_sample_sort_recurse_on}
   seqPerm(seqDef{int u;}(0, _values.length, any::select(heap, _values, arr(u))),
           seqDef{int u;}(0,
                          _valuesBefore_sample_sort.length,
                          any::select(heapBefore_sample_sort, _valuesBefore_sample_sort, arr(u))))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(heapAfter_sample_sort_recurse_on, values, arr(u))),
         seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(anon(heapAfter_partition,
                                         union(allFields(storage),
                                               arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                         anon_heap_LOOP<<anonHeapFunction>>),
                                    values,
                                    arr(u))))';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=heapAfter_sample_sort_recurse_on}
   \forall int b;
     (   b >= 0 & b < num_buckets
      ->   de.wiesler.Sorter.isBucketPartitioned(_values,
                                                 _begin,
                                                 _end,
                                                 bucket_starts[b],
                                                 bucket_starts[1 + b])
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide var='b' occ='5' with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=heapAfter_sample_sort_recurse_on}
   \forall int b;
     (   b >= 0 & b < num_buckets
      ->   de.wiesler.Functions.isSortedSlice(_values,
                                              _begin + bucket_starts[b],
                                              _begin + bucket_starts[1 + b])
         = TRUE)';
macro onestep;
rule allRight;
leave;
# cut 'b_0 < de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>> - 1';

# end post final recursion

# end equal_buckets true

# equal_buckets false

# invariant initially

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   seqPerm(array2seq(heap, _values), array2seq(heapBefore_sample_sort, _valuesBefore_sample_sort))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(Z(0(#)), length(values), int::select(heapAfter_partition, values, arr(u))),
         seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(memset(store(store(store(create(heap, x_arr_2),
                                                             x_arr_2,
                                                             java.lang.Object::<transient>,
                                                             Z(0(#))),
                                                       x_arr_2,
                                                       java.lang.Object::<transactionConditionallyUpdated>,
                                                       FALSE),
                                                 x_arr_2,
                                                 java.lang.Object::<initialized>,
                                                 FALSE),
                                           arrayRange(x_arr_2, Z(0(#)), Z(8(2(1(#))))),
                                           Z(0(#))),
                                    values,
                                    arr(u))))';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   \forall int b;
     (   leq(Z(0(#)), b) & lt(b, num_buckets) & inInt(b)
      ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap,
                                                              bucket_starts,
                                                              arr(javaAddInt(b, Z(1(#))))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide var='b' occ='1' with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || heap:=heapAfter_partition
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || bucket:=Z(0(#))}
   \forall int b;
     (   leq(bucket, b) & lt(b, num_buckets) & inInt(b)
      ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap,
                                                              bucket_starts,
                                                              arr(javaAddInt(b, Z(1(#))))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide var='b' occ='2' with='b_0';

# end invariant initially

# body preserves invariant

select branch='Pre (sample_sort_recurse_on)';
macro onestep;
cut 'x_arr_2 = values';
auto;
macro autopilot-prep match='measuredByCheck(pair(javaSubInt(end, begin), Z(0(#))))';

select succedent formula='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                          union(allFields(storage),
                                                arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                          anon_heap_LOOP<<anonHeapFunction>>),
                                     values,
                                     begin,
                                     end)
= TRUE';
rule observerDependency
                   formula='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                      union(allFields(storage),
                                                                            arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                      anon_heap_LOOP<<anonHeapFunction>>),
                                                                 values,
                                                                 begin,
                                                                 end)
                            = TRUE'
                        on='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                    union(allFields(storage),
                                                                          arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                    anon_heap_LOOP<<anonHeapFunction>>),
                                                               values,
                                                               begin,
                                                               end)'
    inst_termWithLargeHeap='de.wiesler.Functions::isValidSlice(anon(heapAfter_partition,
                                                                    union(allFields(storage),
                                                                          arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                                                    anon_heap_LOOP<<anonHeapFunction>>),
                                                               values,
                                                               begin,
                                                               end)'
    inst_termWithSmallHeap='de.wiesler.Functions::isValidSlice(heap, values, begin, end)';

select succedent formula='de.wiesler.Sorter::smallBucketIsSorted(anon(heapAfter_partition,
                                              union(allFields(storage),
                                                    arrayRange(values,
                                                               begin,
                                                               add(Z(neglit(1(#))), end))),
                                              anon_heap_LOOP<<anonHeapFunction>>),
                                         values,
                                         begin,
                                         end,
                                         arr_1<<selectSK>>,
                                         arr_2<<selectSK>>)
= TRUE';
instantiate hide 
   formula='\forall int b;
              (   lt(b, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & geq(b, bucket_0)
               ->   de.wiesler.Sorter::smallBucketIsSorted(anon(heapAfter_partition,
                                                                union(allFields(storage),
                                                                      arrayRange(values,
                                                                                 begin,
                                                                                 add(Z(neglit(1(#))), end))),
                                                                anon_heap_LOOP<<anonHeapFunction>>),
                                                           values,
                                                           begin,
                                                           end,
                                                           int::select(anon(heapAfter_partition,
                                                                            union(allFields(storage),
                                                                                  arrayRange(values,
                                                                                             begin,
                                                                                             add(Z(neglit(1(#))),
                                                                                                 end))),
                                                                            anon_heap_LOOP<<anonHeapFunction>>),
                                                                       x_arr_2,
                                                                       arr(b)),
                                                           int::select(anon(heapAfter_partition,
                                                                            union(allFields(storage),
                                                                                  arrayRange(values,
                                                                                             begin,
                                                                                             add(Z(neglit(1(#))),
                                                                                                 end))),
                                                                            anon_heap_LOOP<<anonHeapFunction>>),
                                                                       x_arr_2,
                                                                       arr(add(Z(1(#)), b))))
                  = TRUE)'
    with='bucket_0';

select succedent formula='seqPerm(seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(heapAfter_sample_sort_recurse_on, values, arr(u))),
         seqDef{int u;}(Z(0(#)), length(values), any::select(heap, values, arr(u))))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(heapAfter_sample_sort_recurse_on, values, arr(u))),
         seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(anon(heapAfter_partition,
                                         union(allFields(storage),
                                               arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                                         anon_heap_LOOP<<anonHeapFunction>>),
                                    values,
                                    arr(u))))';
                                    
# end body preserves invariant

# use case

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=anon(heapAfter_partition,
                union(allFields(storage), arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                anon_heap_LOOP<<anonHeapFunction>>)}
   seqPerm(seqDef{int u;}(Z(0(#)), length(_values), any::select(heap, _values, arr(u))),
           seqDef{int u;}(Z(0(#)),
                          length(_valuesBefore_sample_sort),
                          any::select(heapBefore_sample_sort, _valuesBefore_sample_sort, arr(u))))';
rule seqPermTrans formula='seqPerm(seqDef{int u;}(Z(0(#)), length(values), int::select(heapAfter_partition, values, arr(u))),
         seqDef{int u;}(Z(0(#)),
                        length(values),
                        any::select(memset(store(store(store(create(heap, x_arr_2),
                                                             x_arr_2,
                                                             java.lang.Object::<transient>,
                                                             Z(0(#))),
                                                       x_arr_2,
                                                       java.lang.Object::<transactionConditionallyUpdated>,
                                                       FALSE),
                                                 x_arr_2,
                                                 java.lang.Object::<initialized>,
                                                 FALSE),
                                           arrayRange(x_arr_2, Z(0(#)), Z(8(2(1(#))))),
                                           Z(0(#))),
                                    values,
                                    arr(u))))';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=anon(heapAfter_partition,
                union(allFields(storage), arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                anon_heap_LOOP<<anonHeapFunction>>)}
   \forall int b;
     (   geq(b, Z(0(#))) & lt(b, num_buckets)
      ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                  _values,
                                                  _begin,
                                                  _end,
                                                  int::select(heap, bucket_starts, arr(b)),
                                                  int::select(heap,
                                                              bucket_starts,
                                                              arr(add(Z(1(#)), b))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide formula='\forall int b;
              (   lt(b, de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>) & geq(b, Z(0(#)))
               ->   de.wiesler.Sorter::isBucketPartitioned(anon(heapAfter_partition,
                                                                union(allFields(storage),
                                                                      arrayRange(values,
                                                                                 begin,
                                                                                 add(Z(neglit(1(#))), end))),
                                                                anon_heap_LOOP<<anonHeapFunction>>),
                                                           values,
                                                           begin,
                                                           end,
                                                           int::select(anon(heapAfter_partition,
                                                                            union(allFields(storage),
                                                                                  arrayRange(values,
                                                                                             begin,
                                                                                             add(Z(neglit(1(#))),
                                                                                                 end))),
                                                                            anon_heap_LOOP<<anonHeapFunction>>),
                                                                       x_arr_2,
                                                                       arr(b)),
                                                           int::select(anon(heapAfter_partition,
                                                                            union(allFields(storage),
                                                                                  arrayRange(values,
                                                                                             begin,
                                                                                             add(Z(neglit(1(#))),
                                                                                                 end))),
                                                                            anon_heap_LOOP<<anonHeapFunction>>),
                                                                       x_arr_2,
                                                                       arr(add(Z(1(#)), b))))
                  = TRUE)'
    with='b_0';

select succedent formula='{_values:=values
  || _begin:=begin
  || _end:=end
  || _storage:=storage
  || (heapBefore_sample_sort:=heap
  || _valuesBefore_sample_sort:=values)
  || bucket_starts:=x_arr_2
  || num_buckets:=de_wiesler_Sorter_PartitionResult_num_buckets_0<<selectSK>>
  || heap_Before_BLOCK_0:=heapAfter_partition
  || exc#69_1:=null
  || heap:=anon(heapAfter_partition,
                union(allFields(storage), arrayRange(values, begin, add(Z(neglit(1(#))), end))),
                anon_heap_LOOP<<anonHeapFunction>>)}
   \forall int b;
     (   geq(b, Z(0(#))) & lt(b, num_buckets)
      ->   de.wiesler.Functions::isSortedSlice(heap,
                                               _values,
                                               add(_begin, int::select(heap, bucket_starts, arr(b))),
                                               add(_begin,
                                                   int::select(heap,
                                                               bucket_starts,
                                                               arr(add(Z(1(#)), b)))))
         = TRUE)';
macro onestep;
rule allRight;
instantiate hide 
    formula='\forall int b;
              (   lt(b, bucket_0) & geq(b, Z(0(#)))
               ->   de.wiesler.Functions::isSortedSlice(anon(heapAfter_partition,
                                                             union(allFields(storage),
                                                                   arrayRange(values,
                                                                              begin,
                                                                              add(Z(neglit(1(#))), end))),
                                                             anon_heap_LOOP<<anonHeapFunction>>),
                                                        values,
                                                        add(begin,
                                                            int::select(anon(heapAfter_partition,
                                                                             union(allFields(storage),
                                                                                   arrayRange(values,
                                                                                              begin,
                                                                                              add(Z(neglit(1(#))),
                                                                                                  end))),
                                                                             anon_heap_LOOP<<anonHeapFunction>>),
                                                                        x_arr_2,
                                                                        arr(b))),
                                                        add(begin,
                                                            int::select(anon(heapAfter_partition,
                                                                             union(allFields(storage),
                                                                                   arrayRange(values,
                                                                                              begin,
                                                                                              add(Z(neglit(1(#))),
                                                                                                  end))),
                                                                             anon_heap_LOOP<<anonHeapFunction>>),
                                                                        x_arr_2,
                                                                        arr(add(Z(1(#)), b)))))
                  = TRUE)'
    with='b_0';
# TODO this is executed somewhere else

# end use case

# end equal_buckets false

tryclose;

"