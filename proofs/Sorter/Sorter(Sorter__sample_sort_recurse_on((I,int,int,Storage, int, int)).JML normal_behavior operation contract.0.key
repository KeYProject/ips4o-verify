\withOptions moreSeqRules:on;

\javaSource "../../src";

\chooseContract "de.wiesler.Sorter[de.wiesler.Sorter::sample_sort_recurse_on([I,int,int,de.wiesler.Storage,[I,int,boolean,int)].JML normal_behavior operation contract.0";

\proofScript "

macro autopilot-prep;

echo 'Validity';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               !_values = _bucket_starts';
leave;

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               geq(int::select(heap, _bucket_starts, arr(_bucket)), Z(0(#)))';

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;

rule allLeftHide
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='Z(0(#))';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               geq(int::select(heap, _bucket_starts, arr(_num_buckets)),
                   int::select(heap, _bucket_starts, arr(add(Z(1(#)), _bucket))))';

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;

rule allLeftHide
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(bucket, Z(1(#)))';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               \forall int b;
                 (   (geq(b, Z(0(#))) & lt(b, _num_buckets) & !b = _bucket)<<SC>>
                  -> (  (   lt(b, _bucket)
                         ->   geq(int::select(heap, _bucket_starts, arr(b)), Z(0(#)))
                            & geq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(b)))
                            & leq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(_bucket))))
                      & (   gt(b, _bucket)
                         ->   geq(int::select(heap, _bucket_starts, arr(b)),
                                  int::select(heap, _bucket_starts, arr(add(Z(1(#)), _bucket))))
                            & geq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(b)))
                            & leq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(_num_buckets)))))<<SC>>)';

macro onestep;
rule allRight;
rule impRight;

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;
rule andRight;

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='Z(0(#))';
rule impLeft
    formula='leq(Z(0(#)), Z(0(#))) & lt(Z(0(#)), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(Z(0(#)), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(Z(0(#)))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='b_0';
rule impLeft
    formula='leq(Z(0(#)), b_0) & lt(b_0, javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))'
     inst_t='add(b_0, Z(1(#)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(b_0, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(b_0, Z(1(#)))) & lt(add(b_0, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='bucket';

select succedent
    formula='gt(b_0, bucket)
             ->   geq(int::select(heap, bucket_starts, arr(b_0)),
                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                      int::select(heap, bucket_starts, arr(b_0)))
                & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                      int::select(heap, bucket_starts, arr(num_buckets)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(bucket, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(bucket, Z(1(#)))) & lt(add(bucket, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(bucket, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(bucket, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(bucket, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(bucket, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='b_0';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='b_0';

rule impLeft
    formula='leq(Z(0(#)), b_0) & lt(b_0, javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))'
     inst_t='add(b_0, Z(1(#)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(b_0, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(b_0, Z(1(#)))) & lt(add(b_0, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='num_buckets';

echo 'if x_5 true';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            add(Z(neglit(1(#))), num_buckets))
                = TRUE)';
macro onestep;
macro onestep;
rule impLeft;
auto;

rule andLeft;

rule Definition_axiom_for_equalityBucketsInRange_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::equalityBucketsInRange(heapAfter_sample_sort,
                                                                       values,
                                                                       begin,
                                                                       end,
                                                                       bucket_starts,
                                                                       num_buckets,
                                                                       add(Z(1(#)), bucket),
                                                                       add(Z(neglit(1(#))), num_buckets))
                           = TRUE'
                       on='de.wiesler.Sorter::equalityBucketsInRange(heapAfter_sample_sort,
                                                                     values,
                                                                     begin,
                                                                     end,
                                                                     bucket_starts,
                                                                     num_buckets,
                                                                     add(Z(1(#)), bucket),
                                                                     add(Z(neglit(1(#))), num_buckets))';
macro onestep;

rule Definition_axiom_for_equalityBucketsInRange_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                                       values,
                                                                       begin,
                                                                       end,
                                                                       bucket_starts,
                                                                       num_buckets,
                                                                       add(Z(1(#)), bucket),
                                                                       add(Z(neglit(1(#))), num_buckets))
                           = TRUE'
                       on='de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                                     values,
                                                                     begin,
                                                                     end,
                                                                     bucket_starts,
                                                                     num_buckets,
                                                                     add(Z(1(#)), bucket),
                                                                     add(Z(neglit(1(#))), num_buckets))';
macro onestep;
rule allRight;

instantiate hide
    formula='\forall int b;
               (     leq(add(Z(1(#)), bucket), b)
                   & lt(b, add(Z(neglit(1(#))), num_buckets))
                   & javaMod(b, Z(2(#))) = Z(1(#))
                ->   de.wiesler.Sorter::isEqualityBucket(heap,
                                                         values,
                                                         javaAddInt(begin,
                                                                    int::select(heap, bucket_starts, arr(b))),
                                                         javaAddInt(begin,
                                                                    int::select(heap,
                                                                                bucket_starts,
                                                                                arr(javaAddInt(b, Z(1(#)))))))
                   = TRUE)'
       with='b_0';
rule impLeft;
auto;

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
       with='b_0';
rule impRight;

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Sorter::isEqualityBucket(heapAfter_sample_sort,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))'
    inst_termWithSmallHeap='de.wiesler.Sorter::isEqualityBucket(heap,
                                                                values,
                                                                javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heap,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                               values,
                                                               begin,
                                                               end,
                                                               bucket_starts,
                                                               num_buckets,
                                                               add(Z(1(#)), bucket),
                                                               num_buckets)
                = TRUE)';
macro onestep;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heapAfter_sample_sort,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heapAfter_sample_sort,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          add(Z(1(#)), bucket),
                                                          num_buckets)';
macro onestep;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

rule allRight;
rule impRight;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
       with='b_0';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::allBucketsPartitioned(heap, values, begin, end, bucket_starts, num_buckets)
                = TRUE)';
leave;

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                             values,
                                                             begin,
                                                             end,
                                                             bucket_starts,
                                                             num_buckets,
                                                             Z(0(#)),
                                                             add(Z(1(#)), bucket))
                = TRUE)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          bucket)
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        bucket)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heapAfter_sample_sort,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          add(Z(1(#)), bucket))
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heapAfter_sample_sort,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        add(Z(1(#)), bucket))';
macro onestep;

rule allRight;

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
      with='b_0';
cut 'b_0 = bucket';
auto;

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Functions::isSortedSlice(heapAfter_sample_sort,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))'
    inst_termWithSmallHeap='de.wiesler.Functions::isSortedSlice(heap,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))';

rule allLeftHide
    formula='\forall int b;
               (   leq(Z(0(#)), b) & lt(b, bucket)
                ->   de.wiesler.Functions::isSortedSlice(heap,
                                                         values,
                                                         javaAddInt(begin,
                                                                    int::select(heap, bucket_starts, arr(b))),
                                                         javaAddInt(begin,
                                                                    int::select(heap,
                                                                                bucket_starts,
                                                                                arr(javaAddInt(b, Z(1(#)))))))
                   = TRUE)'
       inst_t='b_0';

echo 'end if x_5 true';

echo 'if x_5 false';

select succedent formula='{heapAtPre:=heap || exc:=null}
  (  de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                  values,
                                                  begin,
                                                  end,
                                                  bucket_starts,
                                                  num_buckets,
                                                  add(Z(1(#)), bucket),
                                                  num_buckets)
   = TRUE)';
macro onestep;
rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          add(Z(1(#)), bucket),
                                                          num_buckets)';
macro onestep;
rule allRight;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

select succedent formula='{heapAtPre:=heap || exc:=null}
  (  de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                values,
                                                begin,
                                                end,
                                                bucket_starts,
                                                num_buckets,
                                                Z(0(#)),
                                                add(Z(1(#)), bucket))
   = TRUE)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          add(Z(1(#)), bucket))
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        add(Z(1(#)), bucket))';
macro onestep;
rule allRight;

cut 'b_0 = bucket';

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

echo 'end if x_5 false';

tryclose;

"