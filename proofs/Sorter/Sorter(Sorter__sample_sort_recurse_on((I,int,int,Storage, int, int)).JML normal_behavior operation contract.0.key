\withOptions moreSeqRules:on;

\javaSource "../../src";

\chooseContract "de.wiesler.Sorter[de.wiesler.Sorter::sample_sort_recurse_on([I,int,int,de.wiesler.Storage,[I,int,boolean,int)].JML normal_behavior operation contract.0";

\proofScript "

macro autopilot-prep;

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               seqPerm(seqDef{int j;}(begin, end, any::select(heap, values, arr(j))),
                       seqDef{int j;}(begin, end, any::select(heapAtPre, values, arr(j))))';
macro onestep;

cut 'seqPerm(seqDef{int j;}(begin,
                              add(begin, int::select(heap, bucket_starts, arr(bucket))),
                              any::select(heapAfter_sample_sort, values, arr(j))),
               seqDef{int j;}(begin,
                              add(begin, int::select(heap, bucket_starts, arr(bucket))),
                              any::select(heap, values, arr(j))))
     & seqPerm(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                              end,
                              any::select(heapAfter_sample_sort, values, arr(j))),
               seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                              end,
                              any::select(heap, values, arr(j))))';

rule andLeft
    formula='seqPerm(seqDef{int j;}(begin,
                                      add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                      any::select(heapAfter_sample_sort, values, arr(j))),
                       seqDef{int j;}(begin,
                                      add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                      any::select(heap, values, arr(j))))
             & seqPerm(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heapAfter_sample_sort, values, arr(j))),
                       seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heap, values, arr(j))))';

cut '!seqConcat(seqConcat(seqDef{int j;}(begin,
                                                add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                any::select(heapAfter_sample_sort, values, arr(j))),
                                 seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                any::select(heapAfter_sample_sort, values, arr(j)))),
                       seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heapAfter_sample_sort, values, arr(j)))) = seqDef{int j;}(begin, end, any::select(heapAfter_sample_sort, values, arr(j)))';

rule notLeft
    formula='!  seqConcat(seqConcat(seqDef{int j;}(begin,
                                                   add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                   any::select(heapAfter_sample_sort, values, arr(j))),
                                    seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                   add(begin,
                                                       int::select(heap,
                                                                   bucket_starts,
                                                                   arr(add(Z(1(#)), bucket)))),
                                                   any::select(heapAfter_sample_sort, values, arr(j)))),
                          seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                         end,
                                         any::select(heapAfter_sample_sort, values, arr(j))))
              = seqDef{int j;}(begin, end, any::select(heapAfter_sample_sort, values, arr(j)))';

rule equalityToSeqGetAndSeqLenRight
    formula='seqConcat(seqConcat(seqDef{int j;}(begin,
                                                  add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  any::select(heapAfter_sample_sort, values, arr(j))),
                                   seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  add(begin,
                                                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                  any::select(heapAfter_sample_sort, values, arr(j)))),
                         seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                        end,
                                        any::select(heapAfter_sample_sort, values, arr(j))))
             = seqDef{int j;}(begin, end, any::select(heapAfter_sample_sort, values, arr(j)))';

rule andRight;
auto;
auto;

cut '!seqConcat(seqConcat(seqDef{int j;}(begin,
                                                add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                any::select(heap, values, arr(j))),
                                 seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                int::select(heap, values, arr(j)))),
                       seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heap, values, arr(j)))) = seqDef{int j;}(begin, end, any::select(heap, values, arr(j)))';

rule notLeft
    formula='!  seqConcat(seqConcat(seqDef{int j;}(begin,
                                                   add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                   any::select(heap, values, arr(j))),
                                    seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                   add(begin,
                                                       int::select(heap,
                                                                   bucket_starts,
                                                                   arr(add(Z(1(#)), bucket)))),
                                                   int::select(heap, values, arr(j)))),
                          seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                         end,
                                         any::select(heap, values, arr(j))))
              = seqDef{int j;}(begin, end, any::select(heap, values, arr(j)))';
rule equalityToSeqGetAndSeqLenRight
    formula='seqConcat(seqConcat(seqDef{int j;}(begin,
                                                  add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  any::select(heap, values, arr(j))),
                                   seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  add(begin,
                                                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                  int::select(heap, values, arr(j)))),
                         seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                        end,
                                        any::select(heap, values, arr(j))))
             = seqDef{int j;}(begin, end, any::select(heap, values, arr(j)))';

rule andRight;
auto;
auto;

select succedent
    formula='seqPerm(seqDef{int j;}(begin,
                                      add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                      any::select(heapAfter_sample_sort, values, arr(j))),
                       seqDef{int j;}(begin,
                                      add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                      any::select(heap, values, arr(j))))
             & seqPerm(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heapAfter_sample_sort, values, arr(j))),
                       seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                      end,
                                      any::select(heap, values, arr(j))))';

rule andRight;

cut 'seqDef{int j;}(begin,
     add(begin, int::select(heap, bucket_starts, arr(bucket))),
     any::select(heap, values, arr(j))) = seqDef{int j;}(begin,
     add(begin, int::select(heap, bucket_starts, arr(bucket))),
     any::select(heapAfter_sample_sort, values, arr(j)))';

rule applyEqReverse
    formula='seqPerm(seqDef{int j;}(begin,
                                    add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                    any::select(heapAfter_sample_sort, values, arr(j))),
                     seqDef{int j;}(begin,
                                    add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                    any::select(heap, values, arr(j))))'
         on='seqDef{int j;}(begin,
                            add(begin, int::select(heap, bucket_starts, arr(bucket))),
                            any::select(heapAfter_sample_sort, values, arr(j)))';
auto;
auto;
cut 'seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                            end,
                            any::select(heap, values, arr(j))) = seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                            end,
                            any::select(heapAfter_sample_sort, values, arr(j)))';
rule applyEqReverse
    formula='seqPerm(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                    end,
                                    any::select(heapAfter_sample_sort, values, arr(j))),
                     seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                                    end,
                                    any::select(heap, values, arr(j))))'
         on='seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(add(bucket, Z(1(#)))))),
                            end,
                            any::select(heapAfter_sample_sort, values, arr(j)))';
auto;
auto;

exit;

echo 'Permutation property';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::allBucketsPartitioned(heap, values, begin, end, bucket_starts, num_buckets)
                = TRUE)';
macro onestep;
rule Definition_axiom_for_allBucketsPartitioned_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::allBucketsPartitioned(heap, values, begin, end, bucket_starts, num_buckets) = TRUE'
                       on='de.wiesler.Sorter::allBucketsPartitioned(heap, values, begin, end, bucket_starts, num_buckets)';
macro onestep;
rule Definition_axiom_for_allBucketsPartitioned_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::allBucketsPartitioned(heapAfter_sample_sort,
                                                                      values,
                                                                      begin,
                                                                      end,
                                                                      bucket_starts,
                                                                      num_buckets)
                           = TRUE'
                       on='de.wiesler.Sorter::allBucketsPartitioned(heapAfter_sample_sort,
                                                                    values,
                                                                    begin,
                                                                    end,
                                                                    bucket_starts,
                                                                    num_buckets)';
macro onestep;
rule allRight;
rule impRight;

rule Definition_axiom_for_isBucketPartitioned_in_de_wiesler_Sorter
                 formula='de.wiesler.Sorter::isBucketPartitioned(heapAfter_sample_sort,
                                                                   values,
                                                                   begin,
                                                                   end,
                                                                   int::select(heapAfter_sample_sort, bucket_starts, arr(b_0)),
                                                                   int::select(heapAfter_sample_sort,
                                                                               bucket_starts,
                                                                               arr(javaAddInt(b_0, Z(1(#))))))
                          = TRUE'
                      on='de.wiesler.Sorter::isBucketPartitioned(heapAfter_sample_sort,
                                                                 values,
                                                                 begin,
                                                                 end,
                                                                 int::select(heapAfter_sample_sort, bucket_starts, arr(b_0)),
                                                                 int::select(heapAfter_sample_sort,
                                                                             bucket_starts,
                                                                             arr(javaAddInt(b_0, Z(1(#))))))';
macro onestep;
rule allRight;
rule impRight;

rule allLeft
    formula='\forall int b;
               (   leq(Z(0(#)), b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
     inst_t='b_0';
rule impLeft
    formula='leq(Z(0(#)), b_0) & lt(b_0, num_buckets)
             ->   de.wiesler.Sorter::isBucketPartitioned(heap,
                                                         values,
                                                         begin,
                                                         end,
                                                         int::select(heap, bucket_starts, arr(b_0)),
                                                         int::select(heap,
                                                                     bucket_starts,
                                                                     arr(javaAddInt(b_0, Z(1(#))))))
                = TRUE';
auto;

rule Definition_axiom_for_isBucketPartitioned_in_de_wiesler_Sorter
                 formula='de.wiesler.Sorter::isBucketPartitioned(heap,
                                                                   values,
                                                                   begin,
                                                                   end,
                                                                   int::select(heap, bucket_starts, arr(b_0)),
                                                                   int::select(heap,
                                                                               bucket_starts,
                                                                               arr(javaAddInt(b_0, Z(1(#))))))
                          = TRUE'
                      on='de.wiesler.Sorter::isBucketPartitioned(heap,
                                                                 values,
                                                                 begin,
                                                                 end,
                                                                 int::select(heap, bucket_starts, arr(b_0)),
                                                                 int::select(heap,
                                                                             bucket_starts,
                                                                             arr(javaAddInt(b_0, Z(1(#))))))';
macro onestep;
rule allLeft
    formula='\forall int i;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))), i)
                   & lt(i, javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))))
                ->   \forall int j_0;
                       (     leq(javaAddInt(begin,
                                            int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))),
                                 j_0)
                           & lt(j_0, end)
                        -> lt(int::select(heap, values, arr(i)), int::select(heap, values, arr(j_0)))))'
     inst_t='i_0';
rule impLeft
    formula='leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))), i_0)
                & lt(i_0, javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))))
             ->   \forall int j;
                    (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))),
                              j)
                        & lt(j, end)
                     -> lt(int::select(heap, values, arr(i_0)), int::select(heap, values, arr(j))))';
auto;

select succedent
    formula='\forall int j;
               (     leq(javaAddInt(begin,
                                    int::select(heapAfter_sample_sort,
                                                bucket_starts,
                                                arr(javaAddInt(b_0, Z(1(#)))))),
                         j)
                   & lt(j, end)
                -> lt(int::select(heapAfter_sample_sort, values, arr(i_0)),
                      int::select(heapAfter_sample_sort, values, arr(j))))';

rule allRight
    formula='\forall int j;
               (     leq(javaAddInt(begin,
                                    int::select(heapAfter_sample_sort,
                                                bucket_starts,
                                                arr(javaAddInt(b_0, Z(1(#)))))),
                         j)
                   & lt(j, end)
                -> lt(int::select(heapAfter_sample_sort, values, arr(i_0)),
                      int::select(heapAfter_sample_sort, values, arr(j))))';
rule impRight
    formula='leq(javaAddInt(begin,
                                 int::select(heapAfter_sample_sort, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))),
                      j_0)
                & lt(j_0, end)
             -> lt(int::select(heapAfter_sample_sort, values, arr(i_0)),
                   int::select(heapAfter_sample_sort, values, arr(j_0)))';

cut 'lt(bucket, b_0)';

rule allLeftHide
    formula='\forall int j_0;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                   & lt(j_0, end)
                -> lt(int::select(heap, values, arr(i_0)), int::select(heap, values, arr(j_0))))'
     inst_t='j_0';

rule allLeftHide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
     inst_t='b_0';
auto;

rule seqPermDef
    formula='seqPerm(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                    add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                    any::select(heapAfter_sample_sort, values, arr(j))),
                     seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                    add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                    int::select(heap, values, arr(j))))';

rule andLeft
    formula='seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                       add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                       any::select(heapAfter_sample_sort, values, arr(j))))
               = seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                       add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                       int::select(heap, values, arr(j))))
             & \exists Seq s;
                 (    seqLen(s)
                    = seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                            add(begin,
                                                int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                            any::select(heapAfter_sample_sort, values, arr(j))))
                  & seqNPerm(s)
                  & \forall int iv;
                      (   leq(Z(0(#)), iv) & lt(iv, seqLen(s))
                       ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                       add(begin,
                                                           int::select(heap,
                                                                       bucket_starts,
                                                                       arr(add(Z(1(#)), bucket)))),
                                                       any::select(heapAfter_sample_sort, values, arr(j))),
                                        iv)
                          = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                       add(begin,
                                                           int::select(heap,
                                                                       bucket_starts,
                                                                       arr(add(Z(1(#)), bucket)))),
                                                       int::select(heap, values, arr(j))),
                                        int::seqGet(s, iv))))';

rule exLeft
    formula='\exists Seq s;
               (    seqLen(s)
                  = seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                          add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                          any::select(heapAfter_sample_sort, values, arr(j))))
                & seqNPerm(s)
                & \forall int iv;
                    (   leq(Z(0(#)), iv) & lt(iv, seqLen(s))
                     ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                     add(begin,
                                                         int::select(heap,
                                                                     bucket_starts,
                                                                     arr(add(Z(1(#)), bucket)))),
                                                     any::select(heapAfter_sample_sort, values, arr(j))),
                                      iv)
                        = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                     add(begin,
                                                         int::select(heap,
                                                                     bucket_starts,
                                                                     arr(add(Z(1(#)), bucket)))),
                                                     int::select(heap, values, arr(j))),
                                      int::seqGet(s, iv))))';

rule andLeft
    formula='seqLen(s_0)
               = seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                       add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                       any::select(heapAfter_sample_sort, values, arr(j))))
             & seqNPerm(s_0)
             & \forall int iv;
                 (   leq(Z(0(#)), iv) & lt(iv, seqLen(s_0))
                  ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  add(begin,
                                                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                  any::select(heapAfter_sample_sort, values, arr(j))),
                                   iv)
                     = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                  add(begin,
                                                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                  int::select(heap, values, arr(j))),
                                   int::seqGet(s_0, iv)))';

rule andLeft
    formula='seqLen(s_0)
               = seqLen(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                       add(begin, int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                       any::select(heapAfter_sample_sort, values, arr(j))))
             & seqNPerm(s_0)';

cut 'bucket = b_0';

rule allLeftHide
    formula='\forall int iv;
               (   leq(Z(0(#)), iv) & lt(iv, seqLen(s_0))
                ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                any::select(heapAfter_sample_sort, values, arr(j))),
                                 iv)
                   = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                int::select(heap, values, arr(j))),
                                 int::seqGet(s_0, iv)))'
     inst_t='sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))';

cut '!(0 <= int::seqGet(s_0, sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))) & int::seqGet(s_0, sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))) < s_0.length)';

rule seqNPermRange
    formula='seqNPerm(s_0)';

rule allLeftHide
    formula='\forall int iv;
               (   leq(Z(0(#)), iv) & lt(iv, seqLen(s_0))
                ->   leq(Z(0(#)), int::seqGet(s_0, iv))
                   & lt(int::seqGet(s_0, iv), seqLen(s_0))
                   & int::instance(any::seqGet(s_0, iv)) = TRUE)'
     inst_t='sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))';

auto;

rule impLeft
    formula='leq(Z(0(#)), sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))
                & lt(sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))), seqLen(s_0))
             ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                             add(begin,
                                                 int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                             any::select(heapAfter_sample_sort, values, arr(j))),
                              sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))
                = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                             add(begin,
                                                 int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                             int::select(heap, values, arr(j))),
                              int::seqGet(s_0,
                                          sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))))';
auto;

rule allLeftHide
    formula='\forall int i;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))), i)
                   & lt(i, javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))))
                ->   \forall int j_0;
                       (     leq(javaAddInt(begin,
                                            int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))),
                                 j_0)
                           & lt(j_0, end)
                        -> lt(int::select(heap, values, arr(i)), int::select(heap, values, arr(j_0)))))'
     inst_t='add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                 int::seqGet(s_0, sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))))';

rule impLeft
    formula='leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))),
                      add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                          int::seqGet(s_0, sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))))
                & lt(add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                         int::seqGet(s_0, sub(i_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))),
                     javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))))
             ->   \forall int j_0;
                    (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))),
                              j_0)
                        & lt(j_0, end)
                     -> lt(int::select(heap,
                                       values,
                                       arr(add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                               int::seqGet(s_0,
                                                           sub(i_0,
                                                               add(begin,
                                                                   int::select(heap, bucket_starts, arr(bucket)))))))),
                           int::select(heap, values, arr(j_0))))';
auto;

rule allLeftHide
    formula='\forall int j_0;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                   & lt(j_0, end)
                -> lt(int::select(heap,
                                  values,
                                  arr(add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                          int::seqGet(s_0,
                                                      sub(i_0,
                                                          add(begin,
                                                              int::select(heap, bucket_starts, arr(bucket)))))))),
                      int::select(heap, values, arr(j_0))))'
     inst_t='j_0';
rule impLeft
    formula='leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                & lt(j_0, end)
             -> lt(int::select(heap,
                               values,
                               arr(add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                       int::seqGet(s_0,
                                                   sub(i_0,
                                                       add(begin, int::select(heap, bucket_starts, arr(bucket)))))))),
                   int::select(heap, values, arr(j_0)))';
auto;

select branch='CUT: bucket = b_0 FALSE';

rule allLeftHide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
     inst_t='b_0';

rule impLeft
    formula='lt(b_0, num_buckets) & geq(b_0, Z(0(#))) & !b_0 = bucket
             ->   (   lt(b_0, bucket)
                   ->   geq(int::select(heap, bucket_starts, arr(b_0)), Z(0(#)))
                      & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                            int::select(heap, bucket_starts, arr(bucket)))
                      & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                            int::select(heap, bucket_starts, arr(b_0))))
                & (   gt(b_0, bucket)
                   ->   geq(int::select(heap, bucket_starts, arr(b_0)),
                            int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                      & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                            add(mul(begin, Z(neglit(1(#)))), end))
                      & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                            int::select(heap, bucket_starts, arr(b_0))))';
auto;

cut 'begin + bucket_starts[bucket] <= j_0 & j_0 < begin + bucket_starts[bucket + 1]';

rule allLeftHide
    formula='\forall int iv;
               (   leq(Z(0(#)), iv) & lt(iv, seqLen(s_0))
                ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                any::select(heapAfter_sample_sort, values, arr(j))),
                                 iv)
                   = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                                add(begin,
                                                    int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                                int::select(heap, values, arr(j))),
                                 int::seqGet(s_0, iv)))'
     inst_t='sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))';

cut '!(leq(Z(0(#)), sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))
                & lt(sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))), seqLen(s_0)))';

auto;

rule impLeft
    formula='leq(Z(0(#)), sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))
                & lt(sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))), seqLen(s_0))
             ->   any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                             add(begin,
                                                 int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                             any::select(heapAfter_sample_sort, values, arr(j))),
                              sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket)))))
                = any::seqGet(seqDef{int j;}(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                                             add(begin,
                                                 int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket)))),
                                             int::select(heap, values, arr(j))),
                              int::seqGet(s_0,
                                          sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))))';
auto;

cut 'begin + bucket_starts[bucket] <= j_0 & j_0 < begin + bucket_starts[bucket + 1]';

cut '!(0 <= int::seqGet(s_0, sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))) & int::seqGet(s_0, sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))) < s_0.length)';

rule seqNPermRange
    formula='seqNPerm(s_0)';

rule allLeftHide
    formula='\forall int iv;
               (   leq(Z(0(#)), iv) & lt(iv, seqLen(s_0))
                ->   leq(Z(0(#)), int::seqGet(s_0, iv))
                   & lt(int::seqGet(s_0, iv), seqLen(s_0))
                   & int::instance(any::seqGet(s_0, iv)) = TRUE)'
     inst_t='sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))';

auto;

rule allLeftHide
    formula='\forall int j_0;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                   & lt(j_0, end)
                -> lt(int::select(heap, values, arr(i_0)), int::select(heap, values, arr(j_0))))'
     inst_t='add(add(begin, int::select(heap, bucket_starts, arr(bucket))),
                 int::seqGet(s_0, sub(j_0, add(begin, int::select(heap, bucket_starts, arr(bucket))))))';

select branch='CUT: begin + bucket_starts[bucket] <= j_0 & j_0 < begin + bucket_starts[bucket + 1] FALSE';

rule allLeftHide
    formula='\forall int j_0;
               (     leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                   & lt(j_0, end)
                -> lt(int::select(heap, values, arr(i_0)), int::select(heap, values, arr(j_0))))'
     inst_t='j_0';
rule impLeft
    formula='leq(javaAddInt(begin, int::select(heap, bucket_starts, arr(javaAddInt(b_0, Z(1(#)))))), j_0)
                & lt(j_0, end)
             -> lt(int::select(heap, values, arr(i_0)), int::select(heap, values, arr(j_0)))';
auto;

echo 'Validity';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               !_values = _bucket_starts';
leave;

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               geq(int::select(heap, _bucket_starts, arr(_bucket)), Z(0(#)))';

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;

rule allLeftHide
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='Z(0(#))';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               geq(int::select(heap, _bucket_starts, arr(_num_buckets)),
                   int::select(heap, _bucket_starts, arr(add(Z(1(#)), _bucket))))';

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;

rule allLeftHide
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(bucket, Z(1(#)))';

select succedent
    formula='{_values:=values
              || _storage:=storage
              || _bucket_starts:=bucket_starts
              || _num_buckets:=num_buckets
              || _bucket:=bucket
              || heap_Before_BLOCK:=heap
              || exc#65_1:=null}
               \forall int b;
                 (   (geq(b, Z(0(#))) & lt(b, _num_buckets) & !b = _bucket)<<SC>>
                  -> (  (   lt(b, _bucket)
                         ->   geq(int::select(heap, _bucket_starts, arr(b)), Z(0(#)))
                            & geq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(b)))
                            & leq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(_bucket))))
                      & (   gt(b, _bucket)
                         ->   geq(int::select(heap, _bucket_starts, arr(b)),
                                  int::select(heap, _bucket_starts, arr(add(Z(1(#)), _bucket))))
                            & geq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(b)))
                            & leq(int::select(heap, _bucket_starts, arr(add(Z(1(#)), b))),
                                  int::select(heap, _bucket_starts, arr(_num_buckets)))))<<SC>>)';

macro onestep;
rule allRight;
rule impRight;

rule Definition_axiom_for_isValidBucketStarts_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets) = TRUE'
         on='de.wiesler.Functions::isValidBucketStarts(heap, bucket_starts, num_buckets)';
macro onestep;

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)
             & int::select(heap, bucket_starts, arr(Z(0(#)))) = Z(0(#))';

rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             & leq(Z(2(#)), num_buckets)';
rule andLeft
    formula='de.wiesler.Functions::isValidSlice(heap,
                                                    bucket_starts,
                                                    Z(0(#)),
                                                    javaAddInt(num_buckets, Z(1(#))))
               = TRUE
             &   de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                               bucket_starts,
                                                               Z(0(#)),
                                                               javaAddInt(num_buckets, Z(1(#))))
               = TRUE';

rule Definition_axiom_for_isSortedSliceTransitive_in_de_wiesler_Functions
    formula='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                             bucket_starts,
                                                             Z(0(#)),
                                                             javaAddInt(num_buckets, Z(1(#))))
             = TRUE'
         on='de.wiesler.Functions::isSortedSliceTransitive(heap,
                                                           bucket_starts,
                                                           Z(0(#)),
                                                           javaAddInt(num_buckets, Z(1(#))))';
macro onestep;
rule andRight;

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='Z(0(#))';
rule impLeft
    formula='leq(Z(0(#)), Z(0(#))) & lt(Z(0(#)), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(Z(0(#)), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(Z(0(#)))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='b_0';
rule impLeft
    formula='leq(Z(0(#)), b_0) & lt(b_0, javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))'
     inst_t='add(b_0, Z(1(#)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(b_0, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(b_0, Z(1(#)))) & lt(add(b_0, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='bucket';

select succedent
    formula='gt(b_0, bucket)
             ->   geq(int::select(heap, bucket_starts, arr(b_0)),
                      int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                      int::select(heap, bucket_starts, arr(b_0)))
                & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b_0))),
                      int::select(heap, bucket_starts, arr(num_buckets)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(bucket, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(bucket, Z(1(#)))) & lt(add(bucket, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(bucket, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(bucket, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(bucket, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(bucket, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='b_0';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='b_0';

rule impLeft
    formula='leq(Z(0(#)), b_0) & lt(b_0, javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(b_0, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(b_0)), int::select(heap, bucket_starts, arr(j))))'
     inst_t='add(b_0, Z(1(#)))';

rule allLeft
    formula='\forall int i;
               (   leq(Z(0(#)), i) & lt(i, javaAddInt(num_buckets, Z(1(#))))
                -> \forall int j;
                     (   leq(i, j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                      -> leq(int::select(heap, bucket_starts, arr(i)), int::select(heap, bucket_starts, arr(j)))))'
     inst_t='add(b_0, Z(1(#)))';

rule impLeft
    formula='leq(Z(0(#)), add(b_0, Z(1(#)))) & lt(add(b_0, Z(1(#))), javaAddInt(num_buckets, Z(1(#))))
             -> \forall int j;
                  (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                   -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                          int::select(heap, bucket_starts, arr(j))))';
auto;

rule allLeftHide
    formula='\forall int j;
               (   leq(add(b_0, Z(1(#))), j) & lt(j, javaAddInt(num_buckets, Z(1(#))))
                -> leq(int::select(heap, bucket_starts, arr(add(b_0, Z(1(#))))),
                       int::select(heap, bucket_starts, arr(j))))'
     inst_t='num_buckets';

echo 'if x_5 true';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            add(Z(neglit(1(#))), num_buckets))
                = TRUE)';
macro onestep;
macro onestep;
rule impLeft;
auto;

rule andLeft;

rule Definition_axiom_for_equalityBucketsInRange_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::equalityBucketsInRange(heapAfter_sample_sort,
                                                                       values,
                                                                       begin,
                                                                       end,
                                                                       bucket_starts,
                                                                       num_buckets,
                                                                       add(Z(1(#)), bucket),
                                                                       add(Z(neglit(1(#))), num_buckets))
                           = TRUE'
                       on='de.wiesler.Sorter::equalityBucketsInRange(heapAfter_sample_sort,
                                                                     values,
                                                                     begin,
                                                                     end,
                                                                     bucket_starts,
                                                                     num_buckets,
                                                                     add(Z(1(#)), bucket),
                                                                     add(Z(neglit(1(#))), num_buckets))';
macro onestep;

rule Definition_axiom_for_equalityBucketsInRange_in_de_wiesler_Sorter
                  formula='de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                                       values,
                                                                       begin,
                                                                       end,
                                                                       bucket_starts,
                                                                       num_buckets,
                                                                       add(Z(1(#)), bucket),
                                                                       add(Z(neglit(1(#))), num_buckets))
                           = TRUE'
                       on='de.wiesler.Sorter::equalityBucketsInRange(heap,
                                                                     values,
                                                                     begin,
                                                                     end,
                                                                     bucket_starts,
                                                                     num_buckets,
                                                                     add(Z(1(#)), bucket),
                                                                     add(Z(neglit(1(#))), num_buckets))';
macro onestep;
rule allRight;

instantiate hide
    formula='\forall int b;
               (     leq(add(Z(1(#)), bucket), b)
                   & lt(b, add(Z(neglit(1(#))), num_buckets))
                   & javaMod(b, Z(2(#))) = Z(1(#))
                ->   de.wiesler.Sorter::isEqualityBucket(heap,
                                                         values,
                                                         javaAddInt(begin,
                                                                    int::select(heap, bucket_starts, arr(b))),
                                                         javaAddInt(begin,
                                                                    int::select(heap,
                                                                                bucket_starts,
                                                                                arr(javaAddInt(b, Z(1(#)))))))
                   = TRUE)'
       with='b_0';
rule impLeft;
auto;

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
       with='b_0';
rule impRight;

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Sorter::isEqualityBucket(heapAfter_sample_sort,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))'
    inst_termWithSmallHeap='de.wiesler.Sorter::isEqualityBucket(heap,
                                                                values,
                                                                javaAddInt(begin, int::select(heap, bucket_starts, arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heap,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                               values,
                                                               begin,
                                                               end,
                                                               bucket_starts,
                                                               num_buckets,
                                                               add(Z(1(#)), bucket),
                                                               num_buckets)
                = TRUE)';
macro onestep;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heapAfter_sample_sort,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heapAfter_sample_sort,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          add(Z(1(#)), bucket),
                                                          num_buckets)';
macro onestep;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

rule allRight;
rule impRight;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
       with='b_0';

select succedent
    formula='{heapAtPre:=heap || exc:=null || heap:=heapAfter_sample_sort}
               (  de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                             values,
                                                             begin,
                                                             end,
                                                             bucket_starts,
                                                             num_buckets,
                                                             Z(0(#)),
                                                             add(Z(1(#)), bucket))
                = TRUE)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          bucket)
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        bucket)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heapAfter_sample_sort,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          add(Z(1(#)), bucket))
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heapAfter_sample_sort,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        add(Z(1(#)), bucket))';
macro onestep;

rule allRight;

instantiate hide
    formula='\forall int b;
               (   lt(b, num_buckets) & geq(b, Z(0(#))) & !b = bucket
                ->   (   lt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)), Z(0(#)))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(bucket)))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b))))
                   & (   gt(b, bucket)
                      ->   geq(int::select(heap, bucket_starts, arr(b)),
                               int::select(heap, bucket_starts, arr(add(Z(1(#)), bucket))))
                         & leq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               add(mul(begin, Z(neglit(1(#)))), end))
                         & geq(int::select(heap, bucket_starts, arr(add(Z(1(#)), b))),
                               int::select(heap, bucket_starts, arr(b)))))'
      with='b_0';
cut 'b_0 = bucket';
auto;

rule observerDependency
    inst_termWithLargeHeap='de.wiesler.Functions::isSortedSlice(heapAfter_sample_sort,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))'
    inst_termWithSmallHeap='de.wiesler.Functions::isSortedSlice(heap,
                                                                values,
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(b_0))),
                                                                javaAddInt(begin,
                                                                           int::select(heapAfter_sample_sort,
                                                                                       bucket_starts,
                                                                                       arr(javaAddInt(b_0, Z(1(#)))))))';

rule allLeftHide
    formula='\forall int b;
               (   leq(Z(0(#)), b) & lt(b, bucket)
                ->   de.wiesler.Functions::isSortedSlice(heap,
                                                         values,
                                                         javaAddInt(begin,
                                                                    int::select(heap, bucket_starts, arr(b))),
                                                         javaAddInt(begin,
                                                                    int::select(heap,
                                                                                bucket_starts,
                                                                                arr(javaAddInt(b, Z(1(#)))))))
                   = TRUE)'
       inst_t='b_0';

echo 'end if x_5 true';

echo 'if x_5 false';

select succedent formula='{heapAtPre:=heap || exc:=null}
  (  de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                  values,
                                                  begin,
                                                  end,
                                                  bucket_starts,
                                                  num_buckets,
                                                  add(Z(1(#)), bucket),
                                                  num_buckets)
   = TRUE)';
macro onestep;
rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            add(Z(1(#)), bucket),
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          add(Z(1(#)), bucket),
                                                          num_buckets)';
macro onestep;
rule allRight;

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

select succedent formula='{heapAtPre:=heap || exc:=null}
  (  de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                values,
                                                begin,
                                                end,
                                                bucket_starts,
                                                num_buckets,
                                                Z(0(#)),
                                                add(Z(1(#)), bucket))
   = TRUE)';
macro onestep;

rule Definition_axiom_for_allBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          Z(0(#)),
                                                          add(Z(1(#)), bucket))
             = TRUE'
         on='de.wiesler.Sorter::allBucketsInRangeSorted(heap,
                                                        values,
                                                        begin,
                                                        end,
                                                        bucket_starts,
                                                        num_buckets,
                                                        Z(0(#)),
                                                        add(Z(1(#)), bucket))';
macro onestep;
rule allRight;

cut 'b_0 = bucket';

rule Definition_axiom_for_smallBucketsInRangeSorted_in_de_wiesler_Sorter
    formula='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            bucket_starts,
                                                            num_buckets,
                                                            bucket,
                                                            num_buckets)
             = TRUE'
         on='de.wiesler.Sorter::smallBucketsInRangeSorted(heap,
                                                          values,
                                                          begin,
                                                          end,
                                                          bucket_starts,
                                                          num_buckets,
                                                          bucket,
                                                          num_buckets)';
macro onestep;

instantiate hide
    formula='\forall int b;
               (   leq(bucket, b) & lt(b, num_buckets)
                ->   de.wiesler.Sorter::smallBucketIsSorted(heap,
                                                            values,
                                                            begin,
                                                            end,
                                                            int::select(heap, bucket_starts, arr(b)),
                                                            int::select(heap,
                                                                        bucket_starts,
                                                                        arr(javaAddInt(b, Z(1(#))))))
                   = TRUE)'
       with='b_0';

echo 'end if x_5 false';

tryclose;

"